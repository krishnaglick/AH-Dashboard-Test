<h1 id="chat">Chat</h1>

<h2 id="general">General</h2>

<p>actionhero ships with a chat framework which may be used by all persistent connections (<code class="prettyprint">socket</code> and <code class="prettyprint">websocket</code>).  There are methods to create and manage chat rooms and control the users in those rooms.  Chat does not have to be for peer-to-peer communication, and is a metaphor used for many things, including game state in MMOs.</p>

<p>Clients themselves interact with rooms via <code class="prettyprint">verbs</code>.  Verbs are short-form commands that will attempt to modify the connection&rsquo;s state, either joining or leaving a room.  Clients can be in many rooms at once.</p>

<p>Relevant chat verbs are:</p>

<ul>
<li><code class="prettyprint">roomAdd</code></li>
<li><code class="prettyprint">roomLeave</code></li>
<li><code class="prettyprint">roomView</code></li>
<li><code class="prettyprint">say</code></li>
</ul>

<p>The special verb for persistent connections <code class="prettyprint">say</code> makes use of <code class="prettyprint">api.chatRoom.broadcast</code> to tell a message to all other users in the room, IE: <code class="prettyprint">say myRoom Hello World</code> from a socket client or <code class="prettyprint">client.say(&quot;myRoom&quot;, &#39;Hello World&quot;)</code> for a websocket.</p>

<p>Chat on multiple actionHero nodes relies on redis for both chat (pub/sub) and a key store defined by <code class="prettyprint">api.config.redis</code>. Note that if <code class="prettyprint">api.config.redis.fake = true</code>, you will be using an in-memory redis server rather than a real redis process, which does not work to share data across nodes.  The redis store and the key store don&rsquo;t need to be the same instance of redis, but they do need to be the same for all actionhero servers you are running in parallel.  This is how actionhero scales the chat features.</p>

<p>There is no limit to the number of rooms which can be created, but keep in mind that each room stores information in redis, and there load created for each connection.</p>

<h2 id="methods">Methods</h2>

<p>These methods are to be used within your server (perhaps an action or initializer).  They are not exposed directly to clients, but they can be within an action.</p>

<h3 id="api-chatroom-broadcast-connection-room-message-callback">api.chatRoom.broadcast(connection, room, message, callback)</h3>

<ul>
<li>tell a message to all members in a room.</li>
<li>connection can either be a real connection (A message coming from a client), or a mockConnection.  A mockConnection at the very least has the form <code class="prettyprint">{room: &quot;someOtherRoom}</code>.  mockConnections without an id will be assigned the id of 0</li>
<li>The <code class="prettyprint">context</code> of messages sent with <code class="prettyprint">api.chatRoom.broadcast</code> always be <code class="prettyprint">user</code> to differentiate these responses from a <code class="prettyprint">responsee</code> to a request</li>
</ul>

<h3 id="api-chatroom-add-room-callback">api.chatRoom.add(room, callback)</h3>

<ul>
<li>callback will return 1 if you created the room, 0 if it already existed</li>
</ul>

<h3 id="api-chatroom-destroy-room-callback">api.chatRoom.destroy(room, callback)</h3>

<ul>
<li>callback is empty</li>
</ul>

<h3 id="api-chatroom-exists-room-callback">api.chatRoom.exists(room, callback)</h3>

<ul>
<li>callback returns (error, found); found is a boolean</li>
</ul>

<h3 id="api-chatroom-roomstatus-room-callback">api.chatRoom.roomStatus(room, callback)</h3>

<ul>
<li>callback returns (error, details); details is a hash containing room information</li>
<li>details of the form:</li>
</ul>
<pre class="highlight javascript"><code><span class="p">{</span>
  <span class="nl">room</span><span class="p">:</span> <span class="s2">"myRoom"</span><span class="p">,</span>
  <span class="nx">membersCount</span><span class="err">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nx">members</span><span class="err">:</span> <span class="p">{</span>
    <span class="nl">aaa</span><span class="p">:</span> <span class="p">{</span><span class="nl">id</span><span class="p">:</span> <span class="s2">"aaa"</span><span class="p">,</span> <span class="nx">joinedAt</span><span class="err">:</span> <span class="mi">123456789</span> <span class="p">},</span>
    <span class="nx">bbb</span><span class="err">:</span> <span class="p">{</span><span class="nl">id</span><span class="p">:</span> <span class="s2">"bbb"</span><span class="p">,</span> <span class="nx">joinedAt</span><span class="err">:</span> <span class="mi">123456789</span> <span class="p">},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<h3 id="api-chatroom-addmember-connectionid-room-callback">api.chatRoom.addMember(connectionId, room, callback)</h3>

<ul>
<li>callback is of the form (error, wasAdded)</li>
<li>you can add connections from this or any other server in the cluster</li>
</ul>

<h3 id="api-chatroom-removemember-connectionid-room-callback">api.chatRoom.removeMember(connectionId, room, callback)</h3>

<ul>
<li>callback is of the form (error, wasRemoved)</li>
<li>you can remove connections from this or any other server in the cluster</li>
</ul>

<h3 id="api-chatroom-generatememberdetails-connection">api.chatRoom.generateMemberDetails( connection )</h3>

<ul>
<li>defines what is stored from the connection object in the member data</li>
<li>default is <code class="prettyprint">id: connection.id</code></li>
<li>other data that is stored by default is <code class="prettyprint">host: api.id</code> and <code class="prettyprint">joinedAt: new Date().getTime()</code></li>
<li>override the entire method to store custom data <em>that is on the connection</em></li>
</ul>

<h3 id="api-chatroom-sanitizememberdetails-memberdata">api.chatRoom.sanitizeMemberDetails( memberData )</h3>

<ul>
<li>Defines what is pulled out of the member data when returning roomStatus</li>
<li>Defaults to <code class="prettyprint">joinedAt : memberData.joinedAt</code></li>
<li>After method call, always filled with <code class="prettyprint">id</code>, based on the <code class="prettyprint">connection.id</code> used to store the data</li>
<li>Override the entire method to use custom data as defined in <code class="prettyprint">api.chatRoom.generateMemberDetails</code></li>
</ul>

<h3 id="api-chatroom-generatemessagepayload-message">api.chatRoom.generateMessagePayload( message )</h3>

<ul>
<li>Defiens how messages from clients are sanitized</li>
<li>Override the entire method to use custom data as defined in <code class="prettyprint">api.chatRoom.generateMessagePayload</code></li>
</ul>

<h2 id="middleware">Middleware</h2>

<p>There are 4 types of middelware you can install for the chat system: <code class="prettyprint">say</code>, <code class="prettyprint">onSayReceive</code>, <code class="prettyprint">join</code>, and <code class="prettyprint">leave</code>.  You can learn more about <a href="/docs#chat-middleware">chat middleware in the middleware section of this document</a></p>

<h2 id="chatting-to-specific-clients">Chatting to specific clients</h2>

<p>Every connection object also has a <code class="prettyprint">connection.sendMessage(message)</code> method which you can call directly from the server.  </p>

<h2 id="client-use">Client Use</h2>

<p>The details of communicating within a chat room are up to each individual server (see <a href="/docs#websocket-server">websocket</a> or <a href="/docs#socket-server">socket</a>), but the same principals apply:</p>

<ul>
<li>Client will join a room (<code class="prettyprint">client.roomAdd(room)</code>).</li>
<li>Once in the room, clients can send messages (which are strings) to everyone else in the room via <code class="prettyprint">say</code>, ie: <code class="prettyprint">client.say(&#39;room&#39;, Hello World&#39;)</code></li>
<li>Once a client is in a room, they will revive messages from other members of the room as events.  For example, catching say events from the websocket client looks like <code class="prettyprint">client.on(&#39;say&#39;, function(message){ console.log(message); })</code>.  You can inspect <code class="prettyprint">message.room</code> if you are in more than one room.

<ul>
<li>The payload of a message will contain the room, sender, and the message body: <code class="prettyprint">{message: &quot;Hello World&quot;, room: &quot;SecretRoom&quot;, from: &quot;7d419af9-accf-40ac-8d78-9281591dd59e&quot;, context: &quot;user&quot;, sentAt: 1399437579346}</code></li>
</ul></li>
</ul>

<p>If you want to create an authenticated room, there are 2 steps:</p>

<ul>
<li>First, create an action which modifies some property eitehr on the connection object it self, or stores permissions to a database.</li>
<li>Then, create a <code class="prettyprint">joinCallback</code>-style middleware which cheks these values.</li>
</ul>
